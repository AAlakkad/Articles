# CSS مقابل جافاسكريبت، الأساطير تتهاوى

هناك اعتقاد خاطئ بين العديد من مطوّري الويب أن CSS هي الطريقة الوحيدة للقيام بالتحريك (Animations). برزت CSS بقوة كأكثر نظام مدلل خلال سنوات وحتى الآن، وتم الحديث دون توقف بين المطوّرين حول متانتها وتوافقها مع أجهزة الجوال. CSS جيدة لكنها ليست أفضل من جافاسكريبت. هناك بعض الأساطير حول CSS قادت المطوّرين بشكل استباقي لتبني هذا النظام (أي CSS) والتخلي عن كلٍّ من جافاسكريبت والتحريك الخاصّ بها.

الاستخدام الفعّال لـ CSS هو ما جعل المطوّرين يشعرون بالحيرة بينما يقومون بإدارة التفاعل بين العناصر من داخل CSS، يجبرون أنفسهم على جعل مشروعهم متوافقاً مع Internet Explorer 8 و 9، وأخيراً، الابتعاد تماماً عن التحريك الجاهز الذي لا يتوفر إلا عن طريق جافاسكريبت.

هذا المقال هو بشكل كامل حول دحض بعض الأساطير حول CSS وكشف جميع المشاكل الأساسية التي بالكاد يتحدث الناس عنها بسبب إعجابهم بـ CSS. يهدف المقال إلى رفع معرفتك ووعيك بفوائد استخدام جافاسكريبت، حتى يمكنك بسهولة التخلص من المواقف التي تثير غضبك.

لذا، دون مزيد من الحشو دعونا نتناقش حول كل منهم بالتفصيل.

## 1. jQuery

دعونا نبدأ بالأساسيات، يتم الجمع بين جافاسكريبت ومكتبة jQuery بشكل خاطئ . التحريك المصمم بجافاسكريبت سريع ومرن، بينما المصمم بـ jQuery بطيء. السبب أن jQuery -بالرغم من مواصفاتها القوية- لم يكن هدفها الرئيسي تنفيذ التحريك. هناك العديد من الأسباب لدعم هذا:

- jQuery لا يمكنها ببساطة التوقف عن استخدام "إتعاب التنسيق" نظراً لهيكلتها البرمجية التي تخدم عدداً من الأغراض غير التحريك. هذا بشكل عام يسبب تقطّع في المراحل الأولى من التحريك.
- الذاكرة التي تستهلكها jQuery دوماً تحرّك **جمع القمامة** (Garbage Collection) مما يؤدي إلى تجمّد التحريك. نظراً لـ **جمع القمامة**، يمكن للمرء أن يواجه تقطّعاً أثناء التحريك.
- تم تصميم jQuery لتستخدم `set_interval()` وليس **طلب إطار الحركة** (Request Animation Frame  - RAF). عندما لا يكون طلب إطار الحركة موجوداً فيمكن أن ينتج عن ذلك حركات بعدد إطارات منخفض (جودة ودقة الحركة تعتمد على عدد الإطارات التي تظهر في الثانية، العدد المثالي هو 60 إطار في الثانية).


## 2. افتقار التحكم بالتدوير وتحديد الموقع

استخدام المتحكمات للحركات، التدوير، وتحديد المواقع هي إحدى الميزات الأساسية الضرورية أثناء تنفيذ التحريك. في CSS، جميع هذه الدوالّ تم تكديسها في خاصية متعارف عليه هي `tranform`. هذه تُسبب مشاكل عند تحريك شيء ما بطريقة فريدة عن طريق عنصر **مشترك**. على سبيل المثال، إن أردت تحريك "التدوير" و"التكبير" بشكل منفصل، وباستخدام أزمنة مختلفة. هذا  ممكن فقط عن طريق جافاسكريبت ﻷنها تُمكّنك من استخدام حِيل متنوعة، وهذه غير مسموحة في CSS. هذه إحدى مساوئ CSS. هي جيدة فقط من أجل مشاريع تتطلب حركاتٍ بسيطة وليست من أجل تلك المشاريع التي تتطلب اندماج تصميم حركة قوية.


## 3. الأداء مع مكتبتيّ Velocity وGSAP

[Velocity](http://julian.com/research/velocity/) و[GSAP](https://greensock.com/gsap) هما المكتبتان الرائدتان والأكثر شعبية في جافاسكريبت. كلاهما يعمل مع أو بدون jQuery. عندما يتم استخدام أيّ من هاتين المكتبتين جنباً إلى جنب مع jQuery فلا يوجد هناك أي تدهور/تباطؤ من حيث الأداء لأنهما تعملان بشكل مستقل عن حركات jQuery الأساسية.

ويمكن أيضاً لهاتين المكتبتين أن يتم استخدامها بسهولة عندما لا تكون مكتبة jQuery موجودة في الصفحة. وهذا يبين بوضوح أنه بدلاً من ربط جميع أنواع استدعاءات التحريك في عنصر jQuery مشترك- كما هو مبين أدناه- يمكنك بشكل مباشر تمرير العنصر المراد إلى استدعاء الحركة.

```javascript
/* Working without jQuery */

Velocity(element, { opacity: 0.4 }, 900); // Velocity

TweenMax.to(element, 1, { opacity: 0.4 }); // GSAP
```

في المثال السابق، يمكنك ملاحظة أن Velocity تستخدم نفس الصيغة حتى عندما لا يتم استخدام jQuery. قامت فقط بإزاحة جميع العناصر تجاه اليمين لترك مساحة للعناصر المستهدفة.

بالمقابل، في GSAP تم استخدام تصميم كائني التوجه (عن طريق استدعاء كائن يمثّل صنف (Class)) جنباً إلى جنب مع دالّة بسيطة ثابتة. بهذه الطريقة المستخدم يملك تحكم كامل بعملية الحركة.

## 4. معامل وحدة معالجة الرسوم (GPU)

وحدة معالجة رسوم (GPU) مُحسّنة بشكل كامل هي عظيمة لأداء مهام متنوعة تتضمن التعامل مع مصفوفات التحويل (Transform) والشفافية (Opacity)، لهذا السبب جميع المتصفحات المتطورة أول ما تفعله هو تفريغ هذه المهام من وحدة المعالجة المركزية (CPU) إلى وحدة معالجة الرسوم (GPU). الهدف الأساسي هو فصل جميع العناصر المتحركة إلى طبقات خاصة بها في وحدة معالجة الرسوم ﻷنه فور انتهاء النظام من إنشاء طبقات وحدة معالجة الرسوم لا يُظهر النظام أي اهتمام بتحريك البكسلات وجمعهم معاً. لهذا لا يوجد حاجة بتاتاً لحساب كل بكسل في كل دقيقة. بدلاً من ذلك يمكنك توفير كثير من الوقت عن طريق تحريك بكسل واحد فوق الآخر.

**يرجى ملاحظة:** ليست هناك حاجة لإعطاء كل عنصر طبقته الخاصة نظراً لذاكرة الفيديو المحدودة في وحدة معالجة الرسوم. إذا نفدت الذاكرة، كل شيء سيفسد.

من ناحية أخرى، إذا قمتَ بتعريف التحريك في CSS عندئذ ستكون مهمة المتصفح أن يحدد طبقة وحدة معالجة الرسوم لكل عنصر وتبعاً لذلك سيحصل انقسام.

*مع ذلك، هذا أمر يمكنك عمله عن طريق جافاسكريبت أيضاً. كل ما تحتاجه هو تحديد التحويل (Transform) مع خاصية 3D (تماماً مثل `translate3d()` و `matrix3d()`) لجعل المتصفح يعلم عن عملية إنشاء طبقات وحدة معالجة الرسوم للعنصر المستهدف. لذا، فهذا واضح أن وحدة معالجة الرسوم لا توفّر زيادة السرعة لـ CSS فقط بل لجافاسكريبت أيضاً.*


## 5. قوة حركات جافاسكريبت **

جافاسكريبت لديها كل الإمكانيات للفوز بالمقارنة مع CSS من حيث الأداء. جافاسكريبت هي أسرع. ولكن إلى أي حدّ يمكن أن تكون أسرع؟ لنبدأ بأنها مرنة بما فيه الكفاية لإنشاء عرض حركات ثلاثيّة الأبعاد (3D) ملفت للنظر، التي يمكن أن تراها عبر WebGL. وأيضاً سريعة بشكلٍ كافٍ لبناء دعاية وسائط متعددة، والتي كان من الممكن تطويرها باستخدام Flash أو After Effects. وبالتأكيد بناء عالم افتراضي باستخدام جافاسكريبت بمساعدة **Canvas**.

وبقدر ما تكون مكتبات التحريك مهمّة فإن الحديث عن توثيق **Transit** و **Velocity** هو منصف جداً. لمزيد من التوضيح لهذه النقطة، قمنا بتزويد قائمة تحسينات يمكن فقط للحركات المبنية بجافاسكريبت أن تؤديها.

- مزامنة DOM
- التخزين المؤقت للخصائص عبر سلسلة استدعاءات للتخفيف من توليد استعلامات DOM
- التخزين المؤقت لنسب تحويل الواحدات

## الاستنتاج

النقاط المذكورة أعلاه تسلط الضوء بوضوح على براعة التحريك المبنيّب على جافاسكريبت بالمقارنة مع المبنيّ على CSS. ولكن هل هذا يعني أن حركات CSS هي "سيئة"؟ لا، بالتأكيد لا. فهي جيدة ولكن فقط لأداء حركات بسيطة. لمرونة وقدرات فريدة أعلى، يجب أن تعطي جافاسكريبت الأولوية.

----

المصدر: 
http://www.script-tutorials.com/css-vs-javascript-myths-fall-to-pieces/
