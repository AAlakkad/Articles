# CSS مقابل جافاسكريبت، الأساطير تتهاوى

هناك اعتقاد خاطئ بين العديد من مطوّري الويب أن CSS هي الطريقة الوحيدة للقيام بالتحريك (Animations). برزت CSS بقوة كأكثر نظام مدلل خلال سنوات وحتى الآن، وتحدّث المطورون باستمرار حول متانتها وتوافقها مع أجهزة الهاتف. CSS جيدة لكنها ليست أفضل من جافاسكريبت. هناك بعض الأساطير حول CSS قادت المطوّرين بشكل استباقي لتبنّي هذا النظام (أي CSS) والتخلي عن كلٍّ من جافاسكريبت والتحريك الخاصّ بها.

ما يحيّر المطوّرين هو الاستخدام الفعّال لـ CSS، فبينما يقومون بإدارة التفاعل بين العناصر من داخل CSS، يُجبرون أنفسهم أيضاً على جعل مشروعهم متوافقاً مع Internet Explorer 8 و 9، وأخيراً، يتجنّبون التحريك الجاهز الذي لا يتوفر إلا عن طريق جافاسكريبت.

يهدف هذا المقال لدحض بعض الأساطير حول CSS وكشف جميع المشكلات الأساسية التي بالكاد يتحدث الناس عنها بسبب إعجابهم بـ CSS. يهدف المقال إلى رفع معرفتك ووعيك بفوائد استخدام جافاسكريبت، حتى يمكنك بسهولة التخلص من المواقف التي تثير غضبك.

لذا، دون مزيد من الحشو دعونا نتناقش حول كل منهم بالتفصيل.

## 1. jQuery

دعونا نبدأ بالأساسيات، يتم الربط بين جافاسكريبت ومكتبة jQuery بشكل خاطئ . فالتحريك المُصمَّم بجافاسكريبت سريع ومرن، بينما المُصمَّم بـ jQuery بطيء. السبب أنه وبرغم مواصفات jQuery القويةإلا أنها لم تهدف بشكل رئيسي لتنفيذ التحريك. هناك العديد من الأسباب لدعم هذا:

- لا يمكن لمكتبة jQuery ببساطة أن تتوقف عن **تحطيم التنسيق** (layout thrashing) نظراً لهيكلتها البرمجية التي تخدم عدداً من الأغراض غير التحريك. هذا بشكل عام يسبب تقطّعاً في المراحل الأولى من التحريك.
- الذاكرة التي تستهلكها jQuery دوماً تُحفّز **جمع القمامة** (Garbage Collection) مما يؤدي إلى تجمّد التحريك. ونظراً لـ **جمع القمامة**، يمكن للمرء أن يواجه تقطّعاً أثناء التحريك.
- تم تصميم jQuery لتستخدم `set_interval()` وليس **طلب إطار الحركة** (Request Animation Frame  - RAF). عندما لا يكون طلب إطار الحركة موجوداً فيمكن أن ينتج عن ذلك تحريكات بعدد إطارات منخفض (جودة ودقة الحركة تعتمد على عدد الإطارات التي تظهر في الثانية، العدد المثالي هو 60 إطار في الثانية).


## 2. فقر التحكم بالتدوير وتحديد الموقع

من الميزات الأساسية الضرورية أثناء تنفيذ التحريك استخدام المتحكمات لـ: التحريك (ِAnimation)، التدوير (Rotation)، وتحديد المواقع (Positioning) . في CSS، تم تكديس جميع هذه الدوالّ في خاصية معروفة هي `tranform`. هذه الخاصية تُسبب مشاكل عند تحريك شيء ما بطريقة فريدة عن طريق عنصر **مشترك**. على سبيل المثال، إن أردت تحريك "التدوير"(Rotation) و"التكبير" (Scaling) بشكل منفصل، وباستخدام أزمنة مختلفة. فهذا  ممكن فقط عن طريق جافاسكريبت ﻷنها تُمكّنك من استخدام حِيل متنوعة، وهذه غير مسموحة في CSS. هذه إحدى مساوئ CSS. هي جيدة من أجل مشاريع تتطلب تحريكاتٍ بسيطة وليس من أجل المشاريع التي تتطلب اندماج تصميمٍ بتحريكاتٍ كبيرة.


## 3. الأداء مع مكتبتيّ Velocity وGSAP

[Velocity](http://julian.com/research/velocity/) و[GSAP](https://greensock.com/gsap) هما المكتبتان الرائدتان والأكثر شعبية في جافاسكريبت. كلاهما يعمل مع أو بدون jQuery. عندما يتم استخدام أيّ من هاتين المكتبتين جنباً إلى جنب مع jQuery فلا يوجد هناك أي تدهورأو تباطؤ من حيث الأداء لأنهما تعملان بشكل مستقل عن تحريكات jQuery الأساسية.

ويمكن أيضاً لهاتين المكتبتين أن يتم استخدامها بسهولة عندما لا تكون مكتبة jQuery موجودة في الصفحة. وهذا يبين بوضوح أنه بدلاً من ربط جميع أنواع استدعاءات التحريك في عنصر jQuery مشترك- كما هو مبين أدناه- يمكنك بشكل مباشر تمرير العنصر المراد إلى استدعاء الحركة.

```javascript
/* Working without jQuery */

Velocity(element, { opacity: 0.4 }, 900); // Velocity

TweenMax.to(element, 1, { opacity: 0.4 }); // GSAP
```

في المثال السابق، يمكنك ملاحظة أن Velocity تستخدم نفس الصيغة حتى عندما لا يتم استخدام jQuery. قامت فقط بإزاحة جميع العناصر تجاه اليمين لترك مساحة للعناصر المستهدفة.

بالمقابل، في GSAP تم استخدام تصميم كائني التوجه (عن طريق استدعاء كائن يمثّل صنف (Class)) جنباً إلى جنب مع دالّة بسيطة ثابتة. بهذه الطريقة المستخدم يملك تحكم كامل بعملية الحركة.

## 4. معامل وحدة معالجة الرسوم (GPU)

وحدة معالجة رسوم (GPU) مُحسّنة بشكل كامل هي عظيمة لأداء مهام متنوعة تتضمن التعامل مع مصفوفات التحويل (Transform) والشفافية (Opacity)، لهذا السبب جميع المتصفحات المتطورة أول ما تفعله هو تفريغ هذه المهام من وحدة المعالجة المركزية (CPU) إلى وحدة معالجة الرسوم (GPU). الهدف الأساسي هو فصل جميع العناصر المتحركة إلى طبقات خاصة بها في وحدة معالجة الرسوم ﻷنه فور انتهاء النظام من إنشاء طبقات وحدة معالجة الرسوم لا يُظهر النظام أي اهتمام بتحريك البكسلات وجمعهم معاً. لهذا لا يوجد حاجة بتاتاً لحساب كل بكسل في كل دقيقة. بدلاً من ذلك يمكنك توفير كثير من الوقت عن طريق تحريك بكسل واحد فوق الآخر.

**يرجى ملاحظة:** ليست هناك حاجة لإعطاء كل عنصر طبقته الخاصة نظراً لذاكرة الفيديو المحدودة في وحدة معالجة الرسوم. إذا نفدت الذاكرة، كل شيء سيفسد.

من ناحية أخرى، إذا قمتَ بتعريف التحريك في CSS عندئذ ستكون مهمة المتصفح أن يحدد طبقة وحدة معالجة الرسوم لكل عنصر وتبعاً لذلك سيحصل انقسام.

*مع ذلك، هذا أمر يمكنك عمله عن طريق جافاسكريبت أيضاً. كل ما تحتاجه هو تحديد التحويل (Transform) مع خاصية 3D (تماماً مثل `translate3d()` و `matrix3d()`) لجعل المتصفح يعلم عن عملية إنشاء طبقات وحدة معالجة الرسوم للعنصر المستهدف. لذا، فهذا واضح أن وحدة معالجة الرسوم لا توفّر زيادة السرعة لـ CSS فقط بل لجافاسكريبت أيضاً.*


## 5. قوة تحريك جافاسكريبت **

جافاسكريبت لديها كل الإمكانيات للفوز بالمقارنة مع CSS من حيث الأداء. جافاسكريبت هي أسرع. ولكن إلى أي حدّ يمكن أن تكون أسرع؟ لنبدأ بأنها مرنة بما فيه الكفاية لإنشاء عرض تحريك ثلاثيّ الأبعاد (3D) ملفت للنظر، التي يمكن أن تراها عبر WebGL. وأيضاً سريعة بشكلٍ كافٍ لبناء دعاية وسائط متعددة، والتي كان من الممكن تطويرها باستخدام Flash أو After Effects. وبالتأكيد بناء عالم افتراضي باستخدام جافاسكريبت بمساعدة **Canvas**.

وبقدر ما تكون مكتبات التحريك مهمّة فإن الحديث عن توثيق **Transit** و **Velocity** هو منصف جداً. لمزيد من التوضيح لهذه النقطة، قمنا بتزويد قائمة تحسينات يمكن فقط للتحريك المبنيّ بجافاسكريبت أن يؤديها.

- مزامنة DOM
- التخزين المؤقت للخصائص عبر سلسلة استدعاءات للتخفيف من توليد استعلامات DOM
- التخزين المؤقت لنسب تحويل الواحدات

## الاستنتاج

النقاط المذكورة أعلاه تسلط الضوء بوضوح على براعة التحريك المبنيّ على جافاسكريبت بالمقارنة مع المبنيّ على CSS. ولكن هل هذا يعني أن تحريك CSS "سيّء"؟ لا، بالتأكيد لا. فهو جيّد ولكن فقط لأداء تحريك بسيط. لمرونة وقدرات فريدة أعلى، يجب أن تعطي جافاسكريبت الأولوية.

----

المصدر: 
http://www.script-tutorials.com/css-vs-javascript-myths-fall-to-pieces/
