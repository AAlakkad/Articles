# CSS مقابل جافاسكريبت، الأساطير تتهاوى

هناك اعتقاد خاطئ بين العديد من مطوّري الويب أن CSS هي الطريقة الوحيدة للقيام بالتحريك (Animations). برزت CSS بقوة كأكثر نظام مدلل خلال سنوات وحتى الآن، وتحدّث المطورون باستمرار حول متانتها وتوافقها مع أجهزة الهاتف. CSS جيدة لكنها ليست أفضل من جافاسكريبت. هناك بعض الأساطير حول CSS قادت المطوّرين بشكل استباقي لتبنّي هذا النظام (أي CSS) والتخلي عن كلٍّ من جافاسكريبت والتحريك الخاصّ بها.

ما يحيّر المطوّرين هو الاستخدام الفعّال لـ CSS، فبينما يقومون بإدارة التفاعل بين العناصر من داخل CSS، يُجبرون أنفسهم أيضاً على جعل مشروعهم متوافقاً مع Internet Explorer 8 و 9، وأخيراً، يتجنّبون التحريك الجاهز الذي لا يتوفر إلا عن طريق جافاسكريبت.

يهدف هذا المقال لدحض بعض الأساطير حول CSS وكشف جميع المشكلات الأساسية التي بالكاد يتحدث الناس عنها بسبب إعجابهم بـ CSS. يهدف المقال إلى رفع معرفتك ووعيك بفوائد استخدام جافاسكريبت، حتى يمكنك بسهولة التخلص من المواقف التي تثير غضبك.

لذا، دون مزيد من الحشو دعونا نتناقش حول كل منهم بالتفصيل.

## 1. jQuery

دعونا نبدأ بالأساسيات، يتم الربط بين جافاسكريبت ومكتبة jQuery بشكل خاطئ . فالتحريك المُصمَّم بجافاسكريبت سريع ومرن، بينما المُصمَّم بـ jQuery بطيء. السبب أنه وبرغم مواصفات jQuery القويةإلا أنها لم تهدف بشكل رئيسي لتنفيذ التحريك. هناك العديد من الأسباب لدعم هذا:

- لا يمكن لمكتبة jQuery ببساطة أن تتوقف عن **تحطيم التنسيق** (layout thrashing) نظراً لهيكلتها البرمجية التي تخدم عدداً من الأغراض غير التحريك. هذا بشكل عام يسبب تقطّعاً في المراحل الأولى من التحريك.
- الذاكرة التي تستهلكها jQuery دوماً تُحفّز **جمع القمامة** (Garbage Collection) مما يؤدي إلى تجمّد التحريك. ونظراً لـ **جمع القمامة**، يمكن للمرء أن يواجه تقطّعاً أثناء التحريك.
- تم تصميم jQuery لتستخدم `set_interval()` وليس **طلب إطار الحركة** (Request Animation Frame  - RAF). عندما لا يكون طلب إطار الحركة موجوداً فيمكن أن ينتج عن ذلك تحريكات بعدد إطارات منخفض (جودة ودقة الحركة تعتمد على عدد الإطارات التي تظهر في الثانية، العدد المثالي هو 60 إطار في الثانية).


## 2. فقر التحكم بالتدوير وتحديد الموقع

من الميزات الأساسية الضرورية أثناء تنفيذ التحريك استخدام المتحكمات لـ: التحريك (ِAnimation)، التدوير (Rotation)، وتحديد المواقع (Positioning) . في CSS، تم تكديس جميع هذه الدوالّ في خاصية معروفة هي `tranform`. هذه الخاصية تُسبب مشاكل عند تحريك شيء ما بطريقة فريدة عن طريق عنصر **مشترك**. على سبيل المثال، إن أردت تحريك "التدوير"(Rotation) و"التكبير" (Scaling) بشكل منفصل، وباستخدام أزمنة مختلفة. فهذا  ممكن فقط عن طريق جافاسكريبت ﻷنها تُمكّنك من استخدام حِيل متنوعة، وهذه غير مسموحة في CSS. هذه إحدى مساوئ CSS. هي جيدة من أجل مشاريع تتطلب تحريكاتٍ بسيطة وليس من أجل المشاريع التي تتطلب اندماج تصميمٍ بتحريكاتٍ كبيرة.


## 3. الأداء مع مكتبتيّ Velocity وGSAP

[Velocity](http://julian.com/research/velocity/) و[GSAP](https://greensock.com/gsap) هما المكتبتان الرائدتان والأكثر شعبية في جافاسكريبت. كلاهما يعمل مع jQuery أو بدونها. عندما يتم استخدام أيّ من هاتين المكتبتين جنباً إلى جنب مع jQuery فلا يحدث أي تدهورأو تباطؤ في الأداء لأنهما تعملان بشكل منفصل عن تحريكات jQuery الأساسية.

ويمكن أيضاً لهاتين المكتبتين أن يتم استخدامها بسهولة عندما لا تكون مكتبة jQuery موجودة في الصفحة. وهذا يبين بوضوح أنه بدلاً من ربط جميع أنواع استدعاءات التحريك في عنصر jQuery مشترك يمكنك بشكل مباشر تمرير العنصر المراد إلى استدعاء الحركة كما هو مبين أدناه.

```javascript
/* Working without jQuery */

Velocity(element, { opacity: 0.4 }, 900); // Velocity

TweenMax.to(element, 1, { opacity: 0.4 }); // GSAP
```

في المثال السابق، يمكنك ملاحظة أن Velocity تستخدم نفس الصيغة حتى عندما لا يتم استخدام jQuery. قامت فقط بإزاحة جميع العناصر تجاه اليمين لترك مساحة للعناصر المستهدفة.

بالمقابل، في GSAP تم استخدام تصميم كائني التوجه (عن طريق استدعاء كائن يمثّل صنف (Class)) جنباً إلى جنب مع دالّة بسيطة ثابتة. بهذه الطريقة المستخدم يملك تحكم كامل بعملية الحركة.

## 4. معامل وحدة معالجة الرسوم (GPU)

عندما تكون وحدة معالجة رسوم (GPU) مُحسّنة بشكل كامل، عندها ستكون عظيمة لأداء مهام متنوعة كالتعامل مع مصفوفات التحويل (Transform) والشفافية (Opacity)، لهذا السبب أول ما تفعله جميع المتصفحات المتطورة هو تفريغ هذه المهام من وحدة المعالجة المركزية (CPU) إلى وحدة معالجة الرسوم (GPU). الهدف الأساسي هو فصل جميع العناصر المتحركة إلى طبقات خاصة بها في وحدة معالجة الرسوم ﻷنه فور انتهاء النظام من إنشاء طبقات وحدة معالجة الرسوم لا يُظهر النظام أي اهتمام بتحريك البكسلات وجمعهم معاً. لهذا لا يوجد حاجة بتاتاً لحساب كل بكسل بشكل مستمر. بدلاً من ذلك يمكن تحريك بكسل واحد فوق الآخر وتوفير كثير من الوقت.

**ملاحظة:** لا حاجة لإعطاء كل عنصر طبقته الخاصة نظراً لذاكرة الفيديو المحدودة في وحدة معالجة الرسوم. فإذا نفدت الذاكرة سيفسد كل شيء.

من ناحية أخرى، إذا قمتَ بتعريف التحريك في CSS عندئذ ستكون مهمة المتصفح أن يحدد طبقة وحدة معالجة الرسوم لكل عنصر وسيحصل انقسام بسبب ذلك.

*مع ذلك، يمكنك عمل هذا الأمر عن طريق جافاسكريبت أيضاً. كل ما تحتاجه هو تحديد التحويل (Transform) مع خاصية 3D (تماماً مثل `translate3d()` و `matrix3d()`) لجعل المتصفح يعلم عن عملية إنشاء طبقات وحدة معالجة الرسوم للعنصر المستهدف. لذا، فمن الواضح أن وحدة معالجة الرسوم لا توفّر زيادة السرعة لـ CSS فقط بل لجافاسكريبت أيضاً.*


## 5. قوة تحريك جافاسكريبت

لدى جافاسكريبت كل الإمكانيات للفوز بمقارنة الأداء مع CSS. جافاسكريبت هي أسرع. لكن إلى أي حدّ يمكن أن تكون أسرع؟ بدايةً هي مرنة بما فيه الكفاية لإنشاء عرض تحريك ثلاثيّ الأبعاد (3D) ملفت للنظر، الذي يمكن أن تراه عبر WebGL. وجافاسكريبت سريعة بشكلٍ كافٍ لبناء دعاية وسائط متعددة، والتي كان من الممكن تطويرها باستخدام Flash أو After Effects. وبالتأكيد بناء عالم افتراضي باستخدام جافاسكريبت بمساعدة **Canvas**.

بقدر ما تكون مكتبات التحريك هي المعنية في هذا المقال، فإن الحديث الآن عن توثيق مكتبتيّ **Transit** و **Velocity** غير مبرر على الإطلاق. لمزيد من التوضيح لهذه النقطة، قمنا بطرح قائمة تحسينات يمكن فقط للتحريك المبنيّ بجافاسكريبت أن يؤديها:

- مزامنة DOM
- التخزين المؤقت للخصائص عبر سلسلة من الاستدعاءات، للتخفيف من استعلامات DOM
- التخزين المؤقت لنسب تحويل الواحدات

## الاستنتاج

نجد بوضوح كيف أن النقاط المذكورة أعلاه تسلط الضوء على براعة التحريك المبنيّ على جافاسكريبت بالمقارنة مع المبنيّ على CSS. ولكن هل هذا يعني أن تحريك CSS "سيّء"؟ بالتأكيد لا. هو جيّد لأداء تحريك بسيط. لكن لمرونة وقدرات فريدة أعلى، يجب أن تأخذ جافاسكريبت بعين الاعتبار.

----

المصدر: 
http://www.script-tutorials.com/css-vs-javascript-myths-fall-to-pieces/
